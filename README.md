# spatial
Transcriptome-scale spatial expression analysis codes
This respository contains the R codes used for analysis of trascriptome data of DLPFC from the spatialLIBD package. 
Data are about 12 samples belonging to three independet subjects. For each subject two pairs of replicates at a distance of 300 um have been taken. Intrapair replicates are at a distance of 10 um. 10x Genomics Visium technology is used to produce spiatially characterized trascriptome data.   

expr_no_layer.R script is aimed to access the ‘spe’ object retrieving samples’ coordinates and gene expression for the gene of interest. The code is used to compute the mean expression of the gene of interest in each pair of position replicates. Gene expression in terms of counts and logcounts is accessed by means of the assays(spe) spatialLIBD’s function. Two plots per patient are produced in which the gene expression is displayed as circles the diameter of which is proportional to the logcounts of the gene in the given position. If the mean expression is equal or lower than 0 the circle is colored red, otherwise blue. To compute the mean, spots are paired based on their univocal code, that represents single entries of rownames(colData(spe)). The coordinates of the first replicate for each sample are used to plot the results. Coordinates, that are expressed as pixel coordinates in the full resolution Visium image,  are accessed by means of the spatialCoords(spe) spatialLIBD’s function. No layer information is used or shown. 
The computations are performed by the gene_expr() function. To plot data the R function symbols() is used inside the aforementioned function.

spot_based_means.R script is aimed to access the ‘spe’ object to retrieve sample’s coordinates and gene expression for the gene of interest. The code is used to compute the mean expression at spot level considering different levels of data stratification. Gene expressions in terms of counts and logcounts are accessed by means of the assays(spe) spatialLIBD’s function. Mean is computed over all 12 samples, per subject (3 means from 4 replicates each) and per position (6 means from 2 replicates each. 2 positions per subject). The mean computation is performed accessing spots by their univocal code, that represents single entries of rownames(colData(spe)) . Only those spots that are present in all the current replicates are used for mean computation (e.g. the mean over all replicates is done considering the spots that are present in each of the 12 samples). The coordinates of the first sample are arbitrary chosen to plot the results. Coordinates, expressed as pixel coordinates in the full resolution Visium image, are accessed by means of the spatialCoords(spe) spatialLIBD’s function. The spots are shown as circles whose diameter is proportional to the logcounts’ mean and the color is coherent with the layer of belonging. The layer of belonging of each spot is accessed by colData(spe)$layer_guess_reordered_short function. The value returned is a factor variable with L1, L2, L3, L4, L5, L6, WM and NA as possible values. The same spot might have not been mapped to the same layer so the most voted layer for the same spot in different samples has been returned as the layer of belonging. For equally voted layers the first returned is taken. For NA mapped spots, NA is returned. 
Gene expression access and mean computation are performed by the compute_expression() function. Layer of belonging access and retrieval are performed by the layer_guess() function. Coordinates access and retrieval are performed by the coords() function. 
To plot data the R function symbols() is used inside the plot_it() function. 

plot_statistics.R script is used to access the ‘spe’ object to retrieve spot’s information as the layer of belonging (colData(spe)$layer_guess_reordered_short), the position in the subject (0 or 300. colData(spe)$position), the subject (colData(spe)$subject), the number of cells (colData(spe)$cell_count) and the ID key (univocal code for the sample that contains that spot. colData(spe)$key). The spot-level counts for the gene of interest’s expression are fetched, accessing the assays(spe) spatialLIBD’s function. All data are stored in a dataframe object. The code has a function to create a filtered version of the aforementioned dataframe in which all spots whose gene expression is equal to zero are removed. This computation has been done to account for the great sparsity of data. These dataframes are used to compute different plots to analyze the relation between gene expression or cell counts and different combinations of sample, position, layer and cell counts. Parameters. In particular the code has the following plot computation and display functions: 
- the get_number() function that allows to print tables (R table() function) of gene expression with respect to the layer, the subject, the position and the combinations of these.
- the plot_box() function that allows to plot some box plots (R boxplot()) to describe gene expression given the subject, the layer, the position, the cell counts, the position and layer, the position and layer and subject. 
- the plot_hist() function that allows to plot some histograms (R hist() function) of gene expression and cell counts.
- the plot_interaction() function that allows to show some interaction plots (R interaction.plot() function). These functions are used to describe the behavior of a function of the response variable given certain explanatory variable’s values. The function is exploited to show the interaction of the mean of the expression given the layer and the subject, given the layer and the subject, given the cell counts and the layer both in all samples and in each single subject and finally the standard deviation given the layer and the subject.
- the plot_int_zoom() function that allows to show some plots (R plot() function )describing the mean expression given the layer in each patient separately and the mean expression given the layer and the position in each patient separately.
- the plot_cc() function that allows to show some interaction plots (R interaction.plot() ) describing the relation between the mean cell counts given the layer and the position both in all samples and given the subject.
The gene expression’s values are accessed by the get_expression() function. 

column_cluster.R script is aimed to access the ‘spe’ object to retrieve spots’ information as the layer of belonging (spe$layer_guess_reordered_short), the position (0 or 300. spe$position), the subject (spe$subject), the cell counts (spe$cell_count), the ID key (univocal code for the sample that contains that spot. spe$key), the x-coordinate (spatialCoords(spe)[, 1]) and the y-coordinate (spatialCoords(spe)[,2]). Coordinates are expressed as pixel coordinates in the full resolution Visium image. Gene of interest’s expression in terms of gene counts is accessed by means of the assays(spe) spatialLIBD’s function and it is then associated to each spot. All data are stored in a dataframe object. This is accessed to divide the spots into ‘rows’ of belonging: distances between spots’ ‘y’ coordinate are computed and spots below a certain distance threshold are considered part of the same row-class. The threshold is set by manual inspection of spots’ ‘y’ distances. 12 thresholds  have been identified and used. The ‘y’ coordinate has been chosen by visual inspection that revealed spots’ limpid row organization. Spots are clustered to then compute and display the interaction between the mean expression given the layer and spots’ row-class for each sample. The interaction is computed and displayed using the R function interaction.plot(). This computation is performed to assess the change of mean gene expression going through each samples. These computations are performed by the apply_class() and creat_columns() functions.  The gene expression is accessed by the gene_expression() function. 
The script has a second chapter that is aimed to compute the K-means clustering. R kmeans() function is exploited for this task. The computations are performed for each subject and then for each positions inside the same subject. The starting number of random assignments is set to 250.
